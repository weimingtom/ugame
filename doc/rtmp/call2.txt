一、NetConnection.call轮询过程
取自Red5的echo_test例子（RTMP AMF0 Object）

---------------------------------------------
   Client->Server         Server->Client
---------------------------------------------
1. C0握手包，长度0x601    S0握手包，长度0xC01
   首字节0x03             首字节0x03
---------------------------------------------
2. C1握手包，长度0x600
   首字节随机
---------------------------------------------
3. connect包（粘包）
   含AMF0数据      
   首字节0x02              
   
   子包（粘包）
   首字节0xC3              首字节0x02
---------------------------------------------
4. 首字节0x02              首字节0x42

                           _result包
                           首字节0x03  
                           
                           首字节0x42
---------------------------------------------
5. call包 
   含AMF0数据              含AMF0数据
   首字节0x03              首字节0x43
---------------------------------------------
6. call包
   含AMF0数据              含AMF0数据
   首字节0x43              首字节0x43
---------------------------------------------

二、模型描述：
(1) 握手过程中，C0包长度0x601，首字节0x03，
S0包可以是随机内容的，
但需要保证首字节为0x03，长度为0xC01
(2) connect包和C1包内容粘起来
(3) AMF0数据中可能混有0xC?内容的字节（用于分割过长的数据），
出现在connect包的偏移位置0x8C处（内容为0xC3），
应该是为了保证AMF包包体长度总小于等于0x80。
(4) 客户端RTMP包首字节和包体长度
首字节决定包头长度。上面提到的客户端包的首字节有以下情况：
	* C0握手包的0x03：无包头，
		包体长度0x600
	* 非C0握手包的0x03：包头大小12，
		包体长度小于0x80，可能有0xC3的分割。
	* 随机内容：C1握手包。没有包头，
		包体长度0x601
	* 0xC3：包头大小1，用于表示connect包的子包，
		包体长度小于0x80，由前面的AMF包包头中的长度信息计算得到。
	* 0x02：包头大小12，
		包体长度小于0x80，可能有0xC3的分割。
	* 0x43：包头大小8
		包体长度小于0x80，可能有0xC3的分割。
(5)RTMP包首字节结构，长度1 Byte
	* 包头长度(2bit) | 频道ID(6bit)
	其中包头长度的计算包括首字节在内
(6)RTMP包头结构（包含首字节）
	* 包头长度1 Byte：
		首字节(1B)
	* 包头长度8 Bytes：
		首字节(1B) | 时间戳(3B) | 包体总长(3B) | 包类型(1B)
	* 包头长度12 Bytes：
		首字节(1B) | 时间戳(3B) | 包体总长(3B) | 包类型(1B) | 流ID(4B)
(7)服务器RTMP包首字节和包体长度
	* S0包长度0xC01，首字节0x03
	* call包的响应总返回0x43首字节



